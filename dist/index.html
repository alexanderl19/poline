<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="utf-8" />
  <!-- Primary Meta Tags -->
  <title>Poline — esoteric color palette generator</title>
  <meta name="title" content="Poline —  esoteric color palette generator">
  <meta name="description"
    content="poline is lightweight, dependency free and fast JavaScript function written in TypeScript. It draws lines between anchors over polar coordinates to generate pleasing color palettes.">

  <link rel="icon" href="/favicon.4735626c.ico" type="image/x-icon">

  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://meodai.github.io/poline/">
  <meta property="og:title" content="Poline —  esoteric color palette generator">
  <meta property="og:description"
    content="poline is lightweight, dependency free and fast JavaScript function written in TypeScript. It draws lines between anchors over polar coordinates to generate pleasing color palettes.">
  <meta property="og:image" content="https://meodai.github.io/poline/socialfb.png">

  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://meodai.github.io/poline/">
  <meta property="twitter:title" content="Poline —  esoteric color palette generator">
  <meta property="twitter:description"
    content="poline is lightweight, dependency free and fast JavaScript function written in TypeScript. It draws lines between anchors over polar coordinates to generate pleasing color palettes.">
  <meta property="twitter:image" content="https://meodai.github.io/poline/socialfb.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Aboreto&family=Work+Sans:wght@300;400&display=swap" rel="stylesheet">
  
  <style>
    :root {

      --light: #fff;
      --dark: #202124;

      --bg: var(--light);
      --onBg: var(--dark);

      background: var(--bg);
      color: var(--onBg);

      font-family: 'Work Sans', sans-serif;
      font-weight: 300;
      font-size: 0.9rem;
      -webkit-font-smoothing: subpixel-antialiased;

      font-size: calc(0.4rem + 0.5vw);

      accent-color: var(--c0);
    }

    ::-moz-selection { 
      color: var(--c1);
      background: var(--c0);
    }

    ::selection {
      color: var(--c1);
      background: var(--c0);
    }

    a {
      color: var(--onBg);
    }

    a:hover {
      text-decoration: none;
    }

    strong {
      font-weight: 400;
    }

    strong.t {
      font-weight: 300;
    }

    h1, h2, h3, .t, .wheel__huelabel {
      font-family: 'Aboreto', cursive;
    }

    h1 {
      font-size: 5rem;
      margin: 0;
      padding: 0;
      font-weight: normal;
      letter-spacing: -0.05em;
      margin-left: -0.06em;
    }

    h2 {
      font-size: 2.5rem;
      margin: 0;
      padding: 0;
      font-weight: normal;
      letter-spacing: -0.05em;
      margin-left: -0.06em;
    }

    .t-intro {
      margin: 3em 0 1em;
    }


    p {
      line-height: 1.5;
    }

    .poline-picker {
      position: absolute;
      width: min(60vmin, 60%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .poline-picker__circprev {
      width: 12vmin;
      height: 12vmin;
      background: conic-gradient(var(--prev));
      border-radius: 50%;
      position: absolute;
      top: 100%;
      left: 50%;
      z-index: 3;
      transition: transform 0.5s cubic-bezier(0.3, 0.7, 0, 1);
      box-shadow: 0 0 0 0.7vmin var(--bg);
      pointer-events: none;
      transform: translate(-50%, -50%) scale(0.4);
    }

    .picker {
      position: relative;
      width: 100%;
      aspect-ratio: 1;
      --s: .4;
      --l: .5;
      border-radius: 50%;
      background: radial-gradient(closest-side, #000, rgba(255, 255, 255, 0), #fff), 
                  conic-gradient(from 90deg, var(--grad));
    }

    svg {
      position: relative;
      z-index: 2;
      overflow: visible !important;
      width: 100%;
    
    }

    svg line.wheel__line {
      stroke: var(--onBg);
      stroke-width: 0.25;
      stroke-dasharray: 0.5 0.5;
      pointer-events: none;
    }

    svg circle {
      stroke: var(--onBg);
      stroke-width: 0.25;
    }

    svg .wheel__point {
      pointer-events: none;
    }

    svg .wheel__anchor {
      pointer-events: all;
      cursor: grab;
    }

    svg line.wheel__satline {
      stroke-dasharray: 0 0;
      stroke-width: 1;
      stroke-linecap: round;
    }

    svg line.wheel__satline--bg {
      stroke: #fff;
      stroke-width: 1.5;
      stroke-dasharray: 0 0;
    }

    .wheel__huelabel {
      user-select: none;
      pointer-events: none;
      font-weight: normal;
      box-sizing: border-box;
      position: absolute;
      top: 50%;
      left: 50%;
      width: calc(100% + 16vmin);
      transform: translate(-50%, -50%) rotate(calc(var(--i, 0) * 360deg));
      font-size: 1.7vmin;
      padding: 0.2em 3em 0.2em 120.5%;
      z-index: 1;
      text-align: right;
      pointer-events: none;
      transition: font-size 0.3s cubic-bezier(.3,.7,0,1);
    }

    .picker:hover .wheel__huelabel {
      font-size: 1vmin;
    }

    .picker:hover .wheel__huelabel--active {
      font-size: 1.7vmin;
    }

    .wheel__huelabel::before,
    .wheel__huelabel::after {
      content: "";
      position: absolute;
      bottom: 50%;
      left: 91%;
      right: 6vmin;
      height: 1px;
      background: var(--onBg);
      transform: translateY(50%);
    }

    .wheel__huelabel::after {
      height: 30%;
      aspect-ratio: 1;
      right: auto;
      left: 90%;
      background: hsl(calc(360 * var(--i, 0)), 100%, 70%);
      border-radius: 50%;
      border: 1px solid var(--bg);
      transform: translate(-50%, 50%) scale(1);
      transition: transform 0.2s ease-in-out;
    }

    .wheel__huelabel--active::after {
      transform: translate(-50%, 50%) scale(1.2);
    }

    label {
      display: flex;
      margin: 1.5rem 0 0;
      font-size: .8rem;
      justify-content: space-between;
      border: 1px solid #e0e0e0;
      padding: 1.5rem;
    }
    label + label {
      border-top: none;
      margin-top: -1px;
      background-color: var(--bg);
    }
    label + button {
      margin-top: 1.5rem;
    }
    label i {
      text-align: right;
      font-style: normal;
    }
    label .t {
      display: block;
      margin: 0;
      font-size: 1.25rem;
      flex: 0 1 auto;
    }
    select {
      display: block;
      padding: 0;
      border: none;
      font: inherit;
      font-family: inherit;

      font-size: 1rem;
      text-decoration: underline;
      background: transparent;
      text-align: right;
      color: var(--onBg);
    }

    button {
      font-family: 'Aboreto', cursive;
      background-color: var(--onBg);
      color: var(--bg);
    }

    .l-wrap {
      display: flex;
    }

    .l-menu {
      flex: 0 0 40%;
      width: 40%;
      box-sizing: border-box;
      padding: 0 8rem 20vh 8rem;
    }

    .l-demo {
      position: fixed;
      width: 60%;
      height: 100%;
      right: 0;
      border-left: 1px solid #e0e0e0;
    }
    
    .drawer {
      --preview-width: 2rem;
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      width: 30%;
      background: var(--onBg);
      transform: translateX(calc(-100% + var(--preview-width)));
    }

    .drawer__preview {
      position: absolute;
      right: 0;
      bottom: 0;
      top: 0;
      width: var(--preview-width);

      background: linear-gradient(0deg, var(--prev));
    }
    .drawer__preview::before,
    .drawer__preview::after {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      background: linear-gradient(0deg, var(--prev-smooth));
    }
    .drawer__preview::after {
      right: 0;
      width: 1rem;
      left: auto;
      display: none;
    }
    .drawer__preview::before {
      z-index: -1;
      transform: translateX(1rem) scaleY(1.1) translateZ(0);
      filter: blur(15px);
      opacity: 0.5;
      right: 0;
    }
    .l-sec {
      min-height: 20vh;
      opacity: 1;
      transition: 400ms opacity linear;
    }
    .l-sec + .l-sec {
      margin-top: 10vh;
    }
    .l-sec--intro {
      padding-top: 32vh;
      display: flex;
      align-items: center;
    }
    .l-sec__inner {
      width: 100%;
    }
    .l-sec--active {
      opacity: 1; 
    }
    .l-sec__preview {
      position: relative;
      display: block;
      height: 1.75rem;
      background-image: linear-gradient(90deg, var(--prev-smooth)),
                        linear-gradient(90deg, var(--prev));
      background-size: 100% 50%;
      background-position: 0 0, 0 100%;
      background-repeat: no-repeat;
      margin: 0;
    }
    .l-sec__preview::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      top: calc(50% - 1px);
      height: 2px;
      background: var(--bg);
    }
    .l-sec__preview figcaption {
      display: none;
    }
    .l-sec__controls {
      margin-top: 2rem;
      margin-bottom: 2rem;
    }
    code {
      position: relative;
      display: block;
      font-size: .85rem;
      color: var(--onBg);
      background: #fafafa;
      padding: 1.5em 1.2em;
      border-radius: 0.2em;
      border: 1px solid #e0e0e0;
      background-color: var(--bg);
    }
    .code-ex {
      position: relative;
    }
    .code-ex::before {
      opacity: 1;
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, var(--prev-smooth));
      z-index: -1;
      opacity: 0;
      transform: translateX(0);
    }

    .l-sec--active .code-ex::before {
      opacity: 1;
      transform: translateX(-1em);
      transition: 200ms transform linear;
    }

    .toc {
      font-size: 1em;
      list-style-type: upper-roman;
      font-family: 'Aboreto', cursive;
      margin: 3em 0 0;
      padding: 0;
    }

    .toc a {
      font-size: 1em;
      font-family: 'Work Sans', sans-serif;
    }
    .toc li + li {
      margin: 0.5em 0 0;
    }
    .key {
      display: inline-block;
      width: 1.5em;
      height: 1.5em;
      border-radius: 0.2em;
      border: 1px solid rgba(0,0,0,.2);
      box-shadow: 0 2px 0 rgba(0,0,0,.2);
      background: var(--bg);
      text-align: center;
    }
    @media (orientation: portrait) {
      :root {
        font-size: calc(0.6rem + 0.5vw);
        padding: 0;
        margin: 0;
        overflow: hidden;
      }
      body {
        padding: 0;
        margin: 0;
      }
      h1, h2, h3 {
        text-align: center;
      }
      h2, h3 {
        margin-bottom: 1em;
      }
      .l-wrap {
        display: block;
        height: 100%;
        height: -moz-available;          /* WebKit-based browsers will ignore this. */
        height: -webkit-fill-available;  /* Mozilla-based browsers will ignore this. */
        height: fill-available;
      }
      .l-menu {
        position: absolute;
        width: 100%;
        max-height: 100%;
        padding: 50vh 10vw 20vh 10vw;
        overflow-y: scroll;
        -webkit-overflow-scrolling: touch;
      }
      .l-sec--intro {
        padding-top: 0;
      }
      .l-demo {
        position: absolute;
        width: 100%;
        height: 40vh;
        border-left: none;
        z-index: 10;
        border-left: none;
      }
      .l-demo::before {
        content: '';
        position: absolute;
        inset: 0;

        background: rgba(255,255,255,.5);
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);

        margin-top: -1vh;
        clip-path: circle(17vh at 50% 50%);
      }
      .poline-picker {
        height: 27vh;
        width: 27vh;
        margin-top: -1vh;
      }
      .drawer {
        position: absolute;
        z-index: 1;
        width: 100%;
        inset: 0;
        top: 43vh;
        bottom: auto;
        transform: translateY(max(-43vh, calc(-1 * var(--scroll-y, 0px)))) translateY(-30%) translateX(-50%);
        height: calc(var(--preview-width) / 2);
        left: 50%;
        background: none;
        will-change: transform;
      }
      .drawer__preview {
        position: relative;
        width: 100%;
        inset: 0;
        height: 100%;

        background: linear-gradient(90deg, var(--prev));

      }
      .drawer__preview::before {
        left: -1rem;
        right: -1rem;
        top: -1rem;
        bottom: -1rem;
        filter: blur(15px);
        background: linear-gradient(90deg, var(--prev));
        opacity: .5;
        display: none;
      }
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg: var(--dark);
        --onBg: var(--light);
      }

      .l-demo {
        border-left: 1px solid rgba(255, 255, 255, .1);
      }

      label {
        border-color: rgba(255, 255, 255, .1);
      }

      .l-demo::before {
        background: rgba(13,13,14,.05);
      }
    }
  </style>
</head>

<body>
  <main class="l-wrap">
    <section class="l-menu" data-menu>
      <div class="l-sec l-sec--intro">
        <div class="l-sec__inner" data-section="intro">
          <h1>Poline</h1>
          <p class="t-intro">
            "<strong class="t">poline</strong>" is an enigmatic color palette generator, that harnesses the mystical witchcraft of polar coordinates. Its
            methodology, defying conventional color science, is steeped in the esoteric knowledge of the early 20th century. This
            magical technology defies explanation, drawing lines between anchors to produce visually striking and otherworldly
            palettes. It is an indispensable tool for the modern generative sorcerer, and a delight for the eye.
          </p>
        </div>
      </div>

      <aside class="l-sec">
        <div class="l-sec__inner" aria-label="Table of Contents">
          <p>
            The tome of "<strong class="t">Poline</strong>" documentation is a comprehensive guide to the arcane arts of color generation, 
            you will gain an understanding of how this tool creates its mystical and captivating palettes through the following sections.
          </p>
          <ol data-toc class="toc"></ol>
        </div>
      </aside>


      <article class="l-sec">
        <div class="l-sec__inner">
          <h2>Terminology &amp; Working Principles</h2>
          <p>
            The name "<strong class="t">Poline</strong>" <strong aria-label="pronunciation for Poline">/ˈpɔːlaɪn/</strong> represents the essence of the library - <strong>a polar line</strong>. 
            The combination of these two words symbolizes the process of creating a palette by drawing lines between <strong>anchor</strong> points. 
            This unique moniker encapsulates the heart and soul of this micro-library written in TypeScript.
          <p>
          <p>
            In "<strong class="t">Poline</strong>", <strong>anchors</strong> represent the points that the lines are drawn
            between.
            The number of <strong>points</strong> determines the number of colors generated between
            each pair of anchors. The more points, the more colors generated. The positions of these points are determined by
            <strong>position functions</strong>.
          </p>
        </div>
      </article>

      <article class="l-sec">
        <div class="l-sec__inner" data-section="summoning">
          <h2 id="summoning">Summoning</h2>
          <p>
            The use of "<strong class="t">Poline</strong>" begins with the invocation of its command, which can be performed with or without arguments.
            If called without, the tool will generate a mesmerizing palette featuring two randomly selected <strong>anchors.</strong>
          </p>
          <p>
            On the other hand, one can choose to provide their own <strong>anchor</strong> points, 
            represented as a list of <strong>hsl</strong> values, for a more personal touch. 
            The power to shape and mold the colors lies in your hands.
          </p>
          <pre class="code-ex"><code class="language-js" data-code="summoning"></code></pre>
          <p>
            To create a palette, "<strong class="t">Poline</strong>" requires at least two anchor points, but the number of anchors you can provide is limitless.
            The key to remember is that the more anchors you provide, the more challenging it becomes to generate a harmonious color
            palette.
          </p>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="points">
          <h2 id="points">Points</h2>
          <p>
            The magic of "<strong class="t">Poline</strong>" is revealed through its technique 
            of drawing lines between anchor points. The richness of the palette is determined 
            by the number of <strong>points</strong>, with each connection producing a unique color.
          </p>
          <p>
            As shown in the illustration, increasing the number of <strong>points</strong> will yield an even greater array of colors.
            By default, four points are used, but this can easily be adjusted through the 'numPoints' property on your Poline
            instance, as demonstrated in the code example.
          </p>
          <!--p>
            As demonstrated on the illustration, "<strong class="t">Poline</strong>"
            works by drawing lines between the <strong>anchors</strong>. The number of <strong>points</strong>
            determines the number of colors generated between each pair of anchors. 
            The more <strong>points</strong> you have, the more colors you will get.
          </p-->
          <pre class="code-ex"><code class="language-js" data-code="points"></code></pre>
          <p>
            The resulting palette is a product of points multiplied by the number of anchor pairs.
            It can be changed after initialization by setting the <strong>numPoints</strong> property on your "<strong class="t">Poline</strong>" instance.
          </p>
          <div class="l-sec__controls">
            <label>
              <span class="t">Steps</span>
              <i><input type="range" min="1" max="15" value="4" data-steps></i>
            </label>
          </div>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="anchors">
          <h2 id="anchors">Anchors</h2>
          <p>
            At the heart of "<strong class="t">Poline</strong>" lies the concept of <strong>anchors</strong>, the fixed points that serve as the foundation for the creation of
            color palettes. <strong>Anchors</strong> are represented as a <strong>list of hsl</strong> values, which consist of three components: <strong>hue</strong> [0…360],
            <strong>saturation</strong> [0…1], and <strong>lightness</strong> [0…1]. 
          </p>
          <p>
            The choice is yours, whether to provide your own anchor points during
            initialization or to allow "<strong class="t">Poline</strong>" to generate a random selection for you by omitting the 'anchorColors' argument. The
            versatility of "<strong class="t">Poline</strong>" extends beyond its initial setup, as you can also add anchors to your palette at any time using
            the '<strong>addAnchorPoint</strong>' method. This method accepts either a <strong>color</strong> as HSL array values or an array of <strong>X, Y, Z</strong> coordinates, 
            further expanding the possibilities of your color creation.
          </p>
          <pre class="code-ex"><code class="language-js" data-code="anchors"></code></pre>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="UpdatingAnchors">
          <h2 id="UpdatingAnchors">Updating Anchors</h2>
          <p>
            With this feature, you have the power to fine-tune your palette and make adjustments as your creative vision
            evolves. So whether you are looking to make subtle changes or bold alterations, "<strong class="t">Poline</strong>" is
            always ready to help you
            achieve your desired result.
          </p>
          <p>
            The ability to update existing <string>anchors</string> is made possible through the '<strong>updateAnchorPoint</strong>' method. 
            This method accepts the <strong>reference to the anchor</strong> you wish to modify and either a color in the form of <strong>HSL</strong> 
            representation or an <strong>XYZ</strong> position array.
          </p>
          <pre class="code-ex"><code class="language-js" data-code="UpdatingAnchors"></code></pre>
          <div class="l-sec__controls">
            <button data-randomize>Randomize Positions</button>
          </div>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="positionFunction">
          <h2 id="positionFunction">Position Function</h2>
          <p>
            The <strong>position function</strong> in "<strong class="t">Poline</strong>" plays a crucial role in determining the <strong>distribution of colors between the anchors</strong>.
            It works similar to easing functions and can be imported from the "<strong class="t">Poline</strong>" module.
          </p>
          <p>
            A position function is a mathematical function that maps a value <strong>between 0 and 1</strong> to another value between 0 and 1.
            By definition the same position function for all axes "<strong class="t">Poline</strong>" will draw a straight line between the anchors.
            The chosen function will determine the distribution of colors between the anchors.
          </p>
          <pre class="code-ex"><code class="language-js" data-code="positionFunction"></code></pre>
          <p>
            If none is provided, "<strong class="t">Poline</strong>" will use the default function, which is a sinusoidal function.
          </p>
          <p>
            The following position functions are available and can be included by importing the <strong>positionFunctions</strong> object from the "<strong class="t">Poline</strong>" module:
            <ul>
              <li>linearPosition</li>
              <li>exponentialPosition</li>
              <li>quadraticPosition</li>
              <li>cubicPosition</li>
              <li>quarticPosition</li>
              <li>sinusoidalPosition <strong>(default)</strong></li>
              <li>asinusoidalPosition</li>
              <li>arcPosition</li>
            </ul>
          </p>
          <div class="l-sec__controls">
            <label>
              <span><span class="t">Position Fn</span></span>
              <i>
                <select data-select="all">
                </select>
              </i>
            </label>
          </div>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="positionFunctions">
          <h2 id="positionFunctions">Arcs</h2>
          <p>
            By defining <strong>different position functions for each axis</strong>, you can control the distribution of colors along each axis 
            (<strong>positionFunctionX</strong>, <strong>positionFunctionY</strong>, <strong>positionFunctionZ</strong>). 
            This will draw different arcs and create a diverse range of color palettes.
          </p>
          <pre class="code-ex"><code class="language-js" data-code="positionFunctions"></code></pre>
          <!--p>
            The <strong>position functions</strong> are used to determine the position of the 
            <strong>points</strong> between the <strong>anchors</strong>. The <strong>position functions</strong> 
            can be the same for XYZ (positionFunction) or different for each axis (positionFunctionX, positionFunctionY, positionFunctionZ).
          </p>
          <p>
            They function a lot like an easing function and can be imported from the <strong class="t">poline</strong> module.
          </p-->
          <!--p>
            Any function that takes a <strong>number between 0 and 1</strong> and returns a number between 0 and 1 can be used as a <strong>position function</strong>.
            The second argument is called `reverse`. It is a boolean set to true on every second connection between anchors.
          </p-->
          <div class="l-sec__controls">
            <label>
              <span><span class="t">Position fn X</span>(Hue / Light)</span>
              <i><select data-select="x">
              </select></i>
            </label>
            <label>
              <span><span class="t">Position fn Y</span>(Hue / Light)</span>
              <i><select data-select="y">
              </select></i>
            </label>
            <label>
              <span><span class="t">Position fn Z</span> (Saturation)</span>
              <i><select data-select="z">
              </select></i>
            </label>
          </div>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="closedLoop">
          <h2 id="closedLoop">Looping Palette</h2>
          <p>
            By default, the palette is not a closed loop. This means that the last color generated is not the same as the first color.
            If you want the palette to be a closed loop, you can set the <strong>closedLoop</strong> argument to true.
          </p>
          <pre class="code-ex"><code class="language-js" data-code="closedLoop"></code></pre>
          <p>
            It is also possible to close the loop after the fact by setting <strong>poline.closedLoop = true|false</strong>.
          </p>
          <div class="l-sec__controls">
            <label>
              <span class="t">Closed Loop</span>
              <i><input type="checkbox" checked="checked" data-loop></i>
            </label>
          </div>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="hueShift">
          <h2 id="hueShift">Hue Shifting</h2>
          <p>
            With the power of hue shifting, "<strong class="t">Poline</strong>" provides yet another level of customization. 
            This feature allows you to <strong>shift the hue</strong> of the colors generated by a certain amount, giving you the ability to animate your
            palette or create similar color combinations with different hues."
          </p>
          <p>
            "<strong class="t">poline</strong>" supports hue shifting. This means that the hue of the colors will be shifted by a certain amount.
            This can be useful if you want to animate the palette or generate a palette that looks similar to your current palette but using different hues.
          </p>
          <pre class="code-ex"><code class="language-js" data-code="hueShift"></code></pre>
          <p>
            The amount is a int or float between -Infinity and Infinity. It will permanently shift the hue of all colors in the palette.
          </p>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="closestAnchor">
          <h2 id="closestAnchor">Closest Anchor</h2>
          <p>
            In some situations, you might want to know which anchor is closest to a certain position or color.
            This method is used in the visualizer to select the closest anchor on click.
          </p>
          <pre class="code-ex"><code class="language-js" data-code="closestAnchor">poline.getClosestAnchorPoint(
  {xyz: [x, y, null], maxDistance: .1}
)</code></pre>
          <p>
            The <strong>maxDistance</strong> argument is optional and will return null if the closest anchor is further away
            than the maxDistance.
          </p>
          <p>
            Any of the <strong>xyz</strong> or <strong>hsl</strong> components can be null. If they are <strong>null</strong>, they will be ignored.
          </p>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="getColors">
          <h2 id="getColors">Color List</h2>
          <p>
            The '<strong class="t">poline</strong>' instance returns all colors as an array of <strong>hsl</strong> arrays or alternatively as an array of <strong>CSS</strong> strings.
          </p>
          <pre class="code-ex"><code class="language-js" data-code="getColors">poline.colors
poline.colorsCSS</code></pre>
          <div class="l-sec__controls">
            <figure class="l-sec__preview">
              <figcaption>Colors as HSL</figcaption>
            </figure>
          </div>
        </div>
      </article>

      <article class="l-sec">
        <div class="l-sec__inner" data-section="removeAnchor">
          <h2 id="removeAnchor">Remove Anchors</h2>
          <p>
            To remove an anchor, you can use the <strong>removeAnchorPoint</strong> method. 
            It either takes an <strong>anchor</strong> reference or an <strong>index</strong> as an argument.
          </p>
          <pre class="code-ex"><code class="language-js" data-code="removeAnchor"></code></pre>
        </div>
      </article>

      <article class="l-sec">
        <div class="l-sec__inner" data-section="colorSpace">
          <h2 id="colorSpace">Color Model</h2>
          <p>
            To keep the library as lightweight as possible, "<strong class="t">poline</strong>" only supports the <strong>hsl</strong> color model out of the box.
            However, it is easily possible to use other color models by using a library like <a href="https://culorijs.org/api/" target="_blank" rel="noopener noreferrer">culori</a>. 
          <pre class="code-ex"><code class="language-js" data-code="colorSpace"></code></pre>
          <div class="l-sec__controls">
            <label>
              <span class="t">Current Model</span>
              <i><select data-models>
              </select></i>
            </label>
          </div>
        </div>
      </article>

      <article class="l-sec">
        <div class="l-sec__inner" data-section="installation">
          <h2 id="installation">Installation</h2>
          <p>
            "<strong class="t">poline</strong>" is available as an <a href="https://www.npmjs.com/package/poline" target="_blank" rel="noopener noreferrer">npm package</a>. 
            Alternatively you can clone it on <a href="https://github.com/meodai/poline" target="_blank" rel="noopener noreferrer">GitHub</a>.
          </p>
          <pre class="code-ex"><code class="language-js" data-code="installation">npm install poline</code></pre>
          <p>
            You can also use the <a href="https://unpkg.com/poline" target="_blank" rel="noopener noreferrer">unpkg CDN</a> to include the library in your project.
          </p>
          <p>
            I recommend using the <strong>mjs</strong> version of the library. This will allow you to use the <strong>import</strong> syntax.
            But you can also use the <strong>umd</strong> version if you prefer to use the <strong>script</strong> tag.
          </p>
          <pre class="code-ex"><code class="language-html" data-code="cdn">import { 
  Poline 
} from 'https://unpkg.com/poline?module'</code></pre>
        </div>
      </article>

      <aside class="controls l-sec">
        <div class="l-sec__inner" data-section="playground">
          <h2 id="playground">Playground</h2>
          <p>
            Experience the magic of "<strong class="t">poline</strong>" for yourself, dear color explorer. 
            The playground awaits your touch, where you may explore the
            uncharted territories of color creation. Unleash your imagination, and let the sorcery begin!
          </p>
          <p>
            And let not your journey end here, dear sorcerer. Interactive exploration awaits you in the playground below. With a
            simple press of the <strong class="key">P</strong> key, you may <strong>add anchor</strong> points to your whims, and with the <strong class="key" aria-label="backspace">⌫</strong> 
            key, you may <strong>remove the last selected anchor</strong> point. So go forth, and let the magic unfold.
          </p>
          <p>
            Use the browser's color picker to change the color of the <strong>last selected anchor</strong> <strong class="key">C</strong>, or use the <strong class="key" aria-label="left arrow">←</strong> and <strong class="key" aria-label="right arrow">→</strong> keys to change the hue of all colors.
          </p>
          <div class="l-sec__controls">
            <label>
              <span class="t">Steps</span>
              <i><input type="range" min="1" max="15" value="3" data-steps></i>
            </label>
            <label>
              <span class="t">Closed Loop</span>
              <i><input type="checkbox" data-loop></i>
            </label>
            <label>
              <span><span class="t">Position fn X</span>(Hue / Light)</span>
              <i><select data-select="x">
              </select></i>
            </label>
            <label>
              <span><span class="t">Position fn Y</span>(Hue / Light)</span>
              <i><select data-select="y">
              </select></i>
            </label>
            <label>
              <span><span class="t">Position fn Z</span> (Saturation)</span>
              <i><select data-select="z">
              </select></i>
            </label>
            <label>
              <span class="t">Current Model</span>
              <i><select data-models>
              </select></i>
            </label>
            <button data-randomize>Randomize Anchors</button>
          </div>
          <p>
            And remember, the full potential of the "<strong class="t">poline</strong>" playground 
            is best unleashed on a desktop device. So gather your tools, and let the
            mystical journey commence.
          </p>
        </div>
      </aside>

      <article class="l-sec">
        <div class="l-sec__inner" data-section="theEnd">
          <h2 id="theEnd">License</h2>
          <p>
            And thus, the tome of "<strong class="t">poline</strong>" has been written.
            Its mystical powers, steeped in the arcane knowledge of the ancients,
            now reside within these pages. May this compendium serve you in your quest
            for the ultimate color palette.
          </p>
          <p>
            The project is <a href="https://github.com/meodai/poline/blob/main/LICENSE" target="_blank"
              rel="noopener noreferrer">MIT licensed</a> and open source.
            If you find any bugs or have any suggestions please open an issue on <a
              href="https://github.com/meodai/poline/issues " target="_blank" rel="noopener noreferrer">GitHub</a>.
          </p>
        </div>
      </article>
    </section>
    <div class="l-demo">
      <div class="poline-picker">
        <div data-picker class="picker"></div>
        <div class="poline-picker__circprev"></div>
      </div>
    </div>
  </main>

  <div class="drawer">
    <div class="drawer__preview">

    </div>
  </div>


  <script type="module">
    console.clear();
    import { formatHex, converter } from 'https://cdn.skypack.dev/culori';
    import hljs from 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/es/highlight.min.js';
    
    import {
      Poline,
      positionFunctions,
      randomHSLPair,
    } from "./index.mjs";

    const toHSL = converter('hsl');

    const svgscale = 100;
    const namespaceURI = 'http://www.w3.org/2000/svg';

    const hueBasedModels = [{
      key: 'okhsl',
      label: 'OKHSL',
      fn: (hsl) => {return {h : hsl[0], s: hsl[1], l: hsl[2]}},
    },
    {
      key: 'hsl',
      label: 'HSL',
      fn: (hsl) => { return { h: hsl[0], s: hsl[1], l: hsl[2] } },
    }
    , {
      key: 'jch',
      label: 'JCH',
      fn: (hsl) => { return { j: hsl[2] * 0.222, c: hsl[1] * 0.190, h: hsl[0] } },
    }, {
      key: 'oklch',
      label: 'OKLCH',
      fn: (hsl) => { return { l: hsl[2] * 0.999, c: hsl[1] * 0.322, h: hsl[0] } },
    }, {
      key: 'lch',
      label: 'LCH',
      fn: (hsl) => { return { l: hsl[2] * 100, c: hsl[1] * 51.484, h: hsl[0] } },
    }, {
        key: 'dlch',
        label: 'DLCH',
        fn: (hsl) => { return { l: hsl[2] * 100, c: hsl[1] * 51.484, h: hsl[0] } },
      }];

    let currentHueModel = 'hsl';
    let currentModelFn = hueBasedModels.find(m => m.key === currentHueModel).fn;

    const stepsToLabels = (steps = 360 / 10) => new Array(steps)
        .fill('')
        .map((_, i) => `
          <strong class="wheel__huelabel" data-huelabel="${i}" style="--i: ${i / steps}">${i * 10}</strong>`)
        .join('')

    const createCSSRainbowGradient = (steps = 360 / 10) => new Array(steps)
        .fill('')
        .map((_, i) => `hsl(${i / (steps - 1) * 360}, calc(var(--s) * 100%), calc(var(--l,0) * 100%))`)
        .join(',');

    const createSVG = (svgscale = 100) => {
      const $svg = document.createElementNS(
        namespaceURI, 'svg'
      );
      $svg.setAttribute('viewBox', `0 0 ${svgscale} ${svgscale}`);
      return $svg;
    }

    const colorArrToSteppedGradient = (colorsArr) => colorsArr.map(
      (c, i) => `${c} ${i / colorsArr.length * 100}% ${(i + 1) / colorsArr.length * 100}%`
    ).join();

    const $steps = document.querySelectorAll('[data-steps]');
    const $selects = document.querySelectorAll('[data-select]');
    const $xSelect = document.querySelectorAll('[data-select="x"]');
    const $ySelect = document.querySelectorAll('[data-select="y"]');
    const $zSelect = document.querySelectorAll('[data-select="z"]');
    const $allSelect = document.querySelector('[data-select="all"]');
    const $models = document.querySelectorAll('[data-models]');
    const $loop = document.querySelectorAll('[data-loop]');
    const $randomize = document.querySelectorAll('[data-randomize]');
    const $toc = document.querySelector('[data-toc]');

    $models.forEach($model => {
      $model.innerHTML = hueBasedModels
        .map(model => `<option ${model.key == currentHueModel ? 'selected="true"' : ""} value="${model.key}">${model.label}</option>`)
        .join('');
      
      $model.addEventListener('change', (e) => {
        currentHueModel = e.target.value;
        currentModelFn = hueBasedModels.find(m => m.key === currentHueModel).fn;
        $models.forEach($model => $model.value = currentHueModel);
        updateSVG();
      });
    });

    let fnx = 'sinusoidalPosition';
    let fny = 'quadraticPosition';
    let fnz = 'linearPosition';
    let fnAll = 'sinusoidalPosition';

    $selects.forEach($select => {
      Object.keys(positionFunctions).forEach(fn => {
        const $option = document.createElement('option');
        if ($select === $xSelect && fn === fnx) $option.selected = true;
        if ($select === $ySelect && fn === fny) $option.selected = true;
        if ($select === $zSelect && fn === fnz) $option.selected = true;
        if ($select === $allSelect && fn === fnAll) $option.selected = true;
        $option.value = fn;
        $option.textContent = fn;
        $select.appendChild($option);
      });
    });

    let steps = parseInt($steps[0].value);

    let startHue = Math.random() * 360;

    let poline = new Poline({
      /*anchorColors: [
        [startHue, Math.random(), 0.8],
        [(startHue + 60 + Math.random() * 180) % 360, Math.random(), Math.random() * .2],
        [(startHue + 60 + Math.random() * 180) % 360, Math.random(), .8]
      ],*/
      numPoints: steps,
      positionFunctionX: positionFunctions[fnx],
      positionFunctionY: positionFunctions[fny],
      positionFunctionZ: positionFunctions[fnz],
      closedLoop: false,
    });


    // favicon
    let $favicon = document.querySelector('[rel="icon"]');
    const $can = document.createElement('canvas');

    $can.width = 256;
    $can.height = 256;

    let centerX = $can.width / 2;
    let centerY = $can.height / 2;

    const context = $can.getContext("2d");
    const x = $can.width / 2;
    const y = $can.height / 2;
    const radius = Math.min($can.width, $can.height) * .5;
    const counterClockwise = false;
    let parts = 12;
    let fraction = 360 / parts;
    const overlapFix = .5;


    const paintFavicon = (i = 0) => {
      parts = poline.colors.length;
      fraction = 360 / parts;

      context.clearRect(0, 0, $can.width, $can.height);

      context.beginPath();
      context.arc(x, y, radius, 0, 2 * Math.PI);
      context.closePath();
      context.fillStyle = `rgba(255,255,255,.5)`;
      context.fill();

      for (let angle = 0; angle < 360; angle += fraction) {
        let startAngle = (i + angle - 90 - fraction - overlapFix - (fraction * .5)) * Math.PI / 180;
        let endAngle = (i + angle - 90 + overlapFix - (fraction * .5)) * Math.PI / 180;
        const color = poline.colorsCSS[angle / fraction];
        context.beginPath();
        context.moveTo(x, y);
        context.arc(x, y, radius, startAngle, endAngle, counterClockwise);
        context.closePath();
        context.fillStyle = color;
        context.fill();
      }


      $favicon.href = $can.toDataURL('image/png');
    }

    paintFavicon();

    // favicon end

    const $picker = document.querySelector('[data-picker]');
    const hueSteps = 360 / 10;
    
    const $svg = createSVG(svgscale);
    $picker.innerHTML = stepsToLabels(hueSteps);
    const $huelabels = document.querySelectorAll('[data-huelabel]');
    $picker.appendChild($svg);
    
    $picker.style.setProperty('--grad', createCSSRainbowGradient(hueSteps));

    //const hue = Math.random() * 360;

    //poline.addAnchorPoint({color: [(startHue + 60 + Math.random() * 180) % 360, Math.random(), .8] });    
    //poline.addAnchorPoint({color: poline.anchorPoints[0].color});
    //console.log(poline);

    let timer = null;

    function updateSVG () {
      $huelabels.forEach(($huelabel, i) => {
        $huelabel.classList.remove('wheel__huelabel--active');
        // if the HUE label is within the range of the current anchor point
        poline.anchorPoints.forEach(anchor => {
          const currentHue = anchor.color[0];
          currentHue - hueSteps / 2 < i * 10 && currentHue + hueSteps / 2 > i * 10 && $huelabel.classList.add('wheel__huelabel--active');
        });
      });

      $svg.innerHTML = '';

      poline.anchorPoints.forEach(anchor => {
        const $circle = document.createElementNS(namespaceURI, 'circle');
        $circle.setAttribute('cx', anchor.x * svgscale);
        $circle.setAttribute('cy', anchor.y * svgscale);
        $circle.setAttribute('r', 2)
        //anchor.hslCSS
        $circle.classList.add('wheel__anchor');
        $circle.setAttribute('fill', '#fff');
        $svg.appendChild($circle);
      });

      poline.flattenedPoints.forEach((point, i) => {
        const $line = document.createElementNS(namespaceURI, 'line');
        $line.classList.add('wheel__line');
        $line.setAttribute('x1', point.x * svgscale);
        $line.setAttribute('y1', point.y * svgscale);
        const nextI = (i + 1) % poline.flattenedPoints.length;
        $line.setAttribute('x2', poline.flattenedPoints[nextI].x * svgscale);
        $line.setAttribute('y2', poline.flattenedPoints[nextI].y * svgscale);
        if (i !== poline.flattenedPoints.length - 1) {
          $svg.appendChild($line);
        }

        const $circle = document.createElementNS(namespaceURI, 'circle');
        $circle.setAttribute('cx', point.x * svgscale);
        $circle.setAttribute('cy', point.y * svgscale);
        $circle.setAttribute('r', .5 + point.color[1] * 1)
        $circle.classList.add('wheel__point');
        $circle.setAttribute('fill', formatHex({ mode: currentHueModel, ...currentModelFn(point.color) }) );
        $svg.appendChild($circle);
      });
      
      let cssColors = [...poline.colorsCSS];
      let colors = [...poline.colors].map(c => formatHex({ mode: currentHueModel, ...currentModelFn(c) }));
      //colors = [...poline.colors].map(c => formatCss({ mode: 'p3', ...currentModelFn(c) }));
      document.documentElement.style.setProperty(
        '--prev',
        colorArrToSteppedGradient(colors)
      )

      document.documentElement.style.setProperty(
        '--prev-smooth',
        colors.join(',')
      )

      document.documentElement.style.setProperty(
        '--c0',
        colors[colors.length - 1]
      );

      document.documentElement.style.setProperty(
        '--c1',
        colors[0]
      );


      clearTimeout(timer);
      timer = setTimeout(() => {
        paintFavicon();
      }, 100); 
    }

    updateSVG();

    $loop.forEach($l => {
      $l.checked = poline.closedLoop;
      $l.addEventListener('change', () => {
        poline.closedLoop = $l.checked;
        updateSVG();
        $loop.forEach($l => {
          $l.checked = poline.closedLoop;
        });
      });
    });

    $steps.forEach($step => {
      $step.addEventListener('input', () => {
        steps = parseInt($step.value);
        poline.numPoints = steps;
        updateSVG();
        $steps.forEach($step => {
          $step.value = steps;
        });
      });
    });


    $allSelect.addEventListener('input', () => {
      fnAll = $allSelect.value;
      poline.positionFunction = positionFunctions[fnAll];
      updateSVG();
    });

    $xSelect.forEach($xSelect => {
      $xSelect.addEventListener('input', () => {
        fnx = $xSelect.value;
        poline.positionFunctionX = positionFunctions[fnx];
        updateSVG();
        $xSelect.forEach($el => {
          $el.value = fnx;
        });
      });
    });


    $ySelect.forEach($ySelect => {
      $ySelect.addEventListener('input', () => {
        fny = $ySelect.value;
        poline.positionFunctionY = positionFunctions[fny];
        updateSVG();
        $ySelect.forEach($el => {
          $el.value = fnx;
        });
      });
    });

    $zSelect.forEach($zSelect => {
      $zSelect.addEventListener('input', () => {
        fnz = $zSelect.value;
        poline.positionFunctionZ = positionFunctions[fnz];
        updateSVG();
        $zSelect.forEach($el => {
          $el.value = fnz;
        });
      });
    });

    $randomize.forEach($randomize => {
      $randomize.addEventListener('click', () => {
        poline.anchorPoints.forEach(anchor => {
          anchor.hsl = [
            (anchor.color[0] + (-90 + Math.random() * 90)) % 360,
            Math.random(),
            anchor.color[2] + (-.05 + Math.random() * .1)
          ];
        });
        poline.updatePointPairs();
        updateSVG();
      });
    });

    let currentPoint = null;
    let lastSelectedPoint = null;
    let lastX = 0;
    let lastY = 0;

    $picker.addEventListener('pointerdown', (e) => {
      e.stopPropagation();
      const x = lastX = e.offsetX / $picker.offsetWidth;
      const y = lastY = e.offsetY / $picker.offsetHeight;

      if (!currentPoint) {
        
        currentPoint = poline.getClosestAnchorPoint({ 
          xyz: [x, y, null], 
          maxDistance: .1 
        });
        lastSelectedPoint = currentPoint;
      } else {
        currentPoint = null;
      }
    });

    $picker.addEventListener('pointermove', (e) => {
      const x = lastX = e.offsetX / $picker.offsetWidth;
      const y = lastY = e.offsetY / $picker.offsetHeight;

      if (currentPoint) {
        e.stopPropagation();
        poline.updateAnchorPoint({point: currentPoint, xyz: [x, y, currentPoint.z]});
        updateSVG();
      } 
    });

  
  /*
  setInterval(() => {
    poline.anchorPoints[0].hsl = [
      (poline.anchorPoints[0].color[0] + 1) % 360,
      poline.anchorPoints[0].color[1],
      poline.anchorPoints[0].color[2]
    ];

    poline.anchorPoints[2].hsl = [
      (poline.anchorPoints[2].color[0] - 1) % 360,
      poline.anchorPoints[2].color[1],
      poline.anchorPoints[2].color[2]
    ];

    poline.updatePointPairs();
    updateSVG();
  }, 16.66);
  */
  


  $picker.addEventListener('pointerup', (e) => {
    currentPoint = null;
  });

  // listen for keypresses
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Delete' || e.key === 'Backspace') {
      if (!lastSelectedPoint) return;
      poline.removeAnchorPoint({point: lastSelectedPoint});
      updateSVG();
    }

    if (e.key === 'p') {
      lastSelectedPoint = poline.addAnchorPoint({xyz: [lastX, lastY, lastY]});
      updateSVG();
    }

    if (e.key === 'c') {
      if (!lastSelectedPoint) return;
      const $color = document.createElement('input');
      $color.type = 'color';
      $color.classList.add('hidden-color-picker');
      $color.setAttribute('aria-hidden', 'true');
      $color.style.position = 'absolute';
      $color.style.top = '-1000px';
      $color.style.right = '-1000px';
      $color.value = formatHex(lastSelectedPoint.hslCSS);
      $color.addEventListener('input', () => {
        const hslObj = toHSL($color.value);
        poline.updateAnchorPoint({
          point: lastSelectedPoint, color: [hslObj.h || 0, hslObj.s, hslObj.l]
        });
        
        updateSVG();
      });
      document.body.appendChild($color);
      $color.click();
    }

    if (e.key === 'ArrowLeft') {
      poline.shiftHue(-2)
      updateSVG();
    }

    if (e.key === 'ArrowRight') {
      poline.shiftHue(2)
      updateSVG();
    }
  });

  let exStartHue = Math.random() * 360;
  let globalInterval = null;

  // scripts per section
  const storyScripts = [{
    section: 'intro',
    fn: () => {
      console.log('intro');
      poline = new Poline({
        numPoints: steps,
      });
      updateSVG();
    },
  },
  {
    section: 'summoning',
    fn: (section) => {
      console.log('summoning');
      exStartHue = Math.random() * 360;
      poline = new Poline({
        anchorColors: [
          [exStartHue, Math.random(), 0.8],
          [(exStartHue + 60 + Math.random() * 180) % 360, Math.random(), Math.random() * .2],
          /*[(exStartHue + 60 + Math.random() * 180) % 360, Math.random(), .8]*/
        ],
      });
      updateSVG();
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `new Poline({
  anchorColors: [
    [${
      Math.round(poline.anchorPoints[0].color[0])
    }, ${
      poline.anchorPoints[0].color[1].toFixed(2)
    }, ${
      poline.anchorPoints[0].color[2].toFixed(2)
    }],
    [${
      Math.round(poline.anchorPoints[1].color[0])
    }, ${
      poline.anchorPoints[1].color[1].toFixed(2)
    }, ${
      poline.anchorPoints[1].color[2].toFixed(2)
    }],
    //... more colors
  ],
});`;

    hljs.highlightElement($code);
    },
  },
  {
    section: 'points',
    fn: (section) => {
      console.log('points');
      poline.numPoints = 6;
      updateSVG();
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `new Poline({
  numPoints: 6,
});`;
      hljs.highlightElement($code);
    },
  },
  {
    section: 'anchors',
    fn: (section) => {
      console.log('anchors');
      if (poline.anchorPoints.length > 2) {
        poline.anchorPoints.forEach((anchor, i) => {
          if (i > 1) poline.removeAnchorPoint({point: anchor});
        });
      }
      poline.addAnchorPoint({color: [(exStartHue + 60 + Math.random() * 180) % 360, Math.random(), .8] });
      const $code = section.target.querySelector('[data-code]');
      const lastPoint = poline.anchorPoints[poline.anchorPoints.length - 1];
      $code.innerHTML = `poline.addAnchorPoint({
  color: [${
        Math.round(lastPoint.color[0])
      }, ${
        lastPoint.color[1].toFixed(2)
      }, ${
        lastPoint.color[2].toFixed(2)
      }]
});

// or

poline.addAnchorPoint({
  xyz: [${
        lastPoint.position[0].toFixed(2)
      }, ${
        lastPoint.position[1].toFixed(2)
      }, ${
        lastPoint.position[2].toFixed(2)
      }]
});`;
      hljs.highlightElement($code);
      updateSVG();
    },
  },
  {
    section: 'closedLoop',
    fn: (section) => {
      console.log('closedLoop');
      poline.closedLoop = true;
      updateSVG();
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `let poline = new Poline({
  closedLoop: true,
});
// or
poline.closedLoop = true;`;
      hljs.highlightElement($code);
      updateSVG();
    }
  },
  {
    section: 'positionFunction',
    fn: (section) => {
      console.log('Position Function');
      if (poline.anchorPoints.length > 3) {
        poline.anchorPoints.forEach((anchor, i) => {
          if (i > 1) poline.removeAnchorPoint({ point: anchor });
        });
      }
      poline.closedLoop = false;
      poline.positionFunction = positionFunctions.linearPosition;
      poline.updatePointPairs();
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `import {
Poline, positionFunctions
} from 'poline';

new Poline({
  positionFunction: 
    positionFunctions.linearPosition,
});`;
      hljs.highlightElement($code);
      updateSVG();
    },
  },
  {
    section: 'positionFunctions',
    fn: (section) => {
      console.log('Position Functions');
      if (poline.anchorPoints.length > 3) {
        poline.anchorPoints.forEach((anchor, i) => {
          if (i > 1) poline.removeAnchorPoint({point: anchor});
        });
      }
      poline.closedLoop = false;
      poline.positionFunctionX = positionFunctions[fnx];
      poline.positionFunctionY = positionFunctions[fny];
      poline.positionFunctionZ = positionFunctions[fnz];
      $xSelect.forEach($xs => {
        $xs.value = fnx;
      });
      $ySelect.forEach($ys => {
        $ys.value = fny;
      });
      $zSelect.forEach($zs => {
        $zs.value = fnz;
      });
      poline.updatePointPairs();
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `new Poline({
  positionFunctionX: 
    positionFunctions.${poline.positionFunctionX.name},
  positionFunctionY: 
    positionFunctions.${poline.positionFunctionY.name},
  positionFunctionZ: 
    positionFunctions.${poline.positionFunctionZ.name},
});`;
      hljs.highlightElement($code);
      updateSVG();
    },
  },
  {
    section: 'closedLoop',
    fn: (section) => {
      console.log('closedLoop');
      poline.closedLoop = true;
      poline.updatePointPairs();
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `new Poline({
  closedLoop: true,
});`;
      hljs.highlightElement($code);
      updateSVG()
    },
  },
  {
    section: 'UpdatingAnchors',
    fn: (section) => {
      console.log('Updating Anchors');
      poline.anchorPoints.forEach((anchor, i) => {
        const hsl = anchor.color;
        poline.updateAnchorPoint({
          point: anchor,
          color: [
            hsl[0] + Math.random() * 60 - 30,
            hsl[1],
            hsl[1],
          ],
        });
      });
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `poline.updateAnchorPoint({
  point: poline.anchorPoints[0],
  color: [${
      Math.round(poline.anchorPoints[0].color[0])
    }, ${
      poline.anchorPoints[0].color[1].toFixed(2)
    }, ${
      poline.anchorPoints[0].color[2].toFixed(2)
    }]
});`;
      hljs.highlightElement($code);
      updateSVG();
    }, 
  },
  {
    section: 'closestAnchor',
    fn: (section) => {
      console.log('closestAnchor');
      const $code = section.target.querySelector('[data-code]');
      hljs.highlightElement($code);
    },
  },
  {
    section: 'removeAnchor',
    fn: (section) => {
      console.log('removeAnchor');

      poline.closedLoop = false;
      if (poline.anchorPoints.length < 3) {
        while (poline.anchorPoints.length < 3) {
          poline.addAnchorPoint({color: [(exStartHue + 60 + Math.random() * 180) % 360, Math.random(), .8] });
        }
      }

      poline.removeAnchorPoint({index: poline.anchorPoints.length - 1});
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `poline.removeAnchorPoint({
  point: poline.anchorPoints[
    poline.anchorPoints.length - 1
  ]
});
  // or
poline.removeAnchorPoint({
  index: poline.anchorPoints.length - 1
});`;
      hljs.highlightElement($code);
      updateSVG();
    },
  },
  {
    section: 'colorSpace',
    fn: (section) => {
      console.log('colorSpace');
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `import {Poline} from "poline";
import {formatHex} from "culori";
const poline = new Poline(/** options */);

const OKHslColors = [...poline.colors].map(
  c => formatHex({ 
    mode: 'okhsl', 
    {
      h: c.hsl[0], 
      s: c.hsl[1], 
      l: c.hsl[2]}
  })
);
const LCHColors = [...poline.colors].map(
  c => formatHex({ 
    mode: 'lch', 
    { 
      h: hsl[0],
      c: hsl[1] * 51.484,
      l: hsl[2] * 100,  
    }
  })
);`
      hljs.highlightElement($code);
      updateSVG();
    },
  },
  {
    section: 'hueShift',
    fn: (section) => {
      console.log('hueShift');
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `poline.shiftHue(1);`;
      hljs.highlightElement($code);
      globalInterval = setInterval(() => {
        poline.shiftHue(1);
        updateSVG();
      }, 16.66);
    }
  },
  {
    section: 'getColors',
    fn: (section) => {
      console.log('getColors');
      const $code = section.target.querySelector('[data-code]');
      hljs.highlightElement($code);
      updateSVG();
    },
  },
  {
    section: 'installation',
    fn: (section) => {
      console.log('Installation');
      const $code = section.target.querySelectorAll('[data-code]');
      $code.forEach($c => hljs.highlightElement($c));
    },
  }
];
  
  // create a table of contents
  const $sections = document.querySelectorAll('[data-section]');
  $sections.forEach($s => {
    const $h2 = $s.querySelector('h2');
    if ($h2) {
      const $li = document.createElement('li');
      $li.innerHTML = `<a href="#${$h2.id}">${$h2.innerHTML}</a>`;
      $toc.appendChild($li);
    }
  });

  $toc.addEventListener('click', (e) => {
    e.preventDefault();
    const $a = e.target;
    if ($a.tagName !== 'A') return;
    const $h2 = document.querySelector(`#${$a.getAttribute('href').replace('#', '')}`);
    $h2.scrollIntoView({behavior: 'smooth'});
  });

  // create an intersection onserver for all the `data-section`s
  const sections = [...document.querySelectorAll('[data-section]')];
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        // find the script for this section in storyScripts
        const script = storyScripts.find(s => s.section === entry.target.dataset.section);
        if (script) {
          clearInterval(globalInterval);
          script.fn(entry);
        }
        // add .l-sec--active to the section when it's in view
        // and remove it on all other sections
        sections.forEach(section => {
          if (section === entry.target) {
            section.parentElement.classList.add('l-sec--active');
          } else {
            section.parentElement.classList.remove('l-sec--active');
          }
        });
        
      }
    });
  }, {
    rootMargin: '0px 0px -50% 0px'
  });

  sections.forEach(section => {
    observer.observe(section);
  });

  const $dmenu = document.querySelector('[data-menu]');

  $dmenu.addEventListener('scroll', (e) => {
    const scrollY = $dmenu.scrollTop;
    document.documentElement.style.setProperty('--scroll-y', `${scrollY}px`);
  });
  </script>
</body>

</html>