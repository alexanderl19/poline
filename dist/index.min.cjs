"use strict";var F=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var C=Object.prototype.hasOwnProperty;var u=Math.pow;var w=(n,o)=>{for(var t in o)F(n,t,{get:o[t],enumerable:!0})},v=(n,o,t,i)=>{if(o&&typeof o=="object"||typeof o=="function")for(let r of y(o))!C.call(n,r)&&r!==t&&F(n,r,{get:()=>o[r],enumerable:!(i=x(o,r))||i.enumerable});return n};var g=n=>v(F({},"__esModule",{value:!0}),n);var H={};w(H,{Poline:()=>d,hslToPoint:()=>m,pointToHSL:()=>M,positionFunctions:()=>$,randomHSLPair:()=>_,randomHSLTriple:()=>L});module.exports=g(H);var M=n=>{let[o,t,i]=n,r=.5,c=.5,s=Math.atan2(t-c,o-r)*(180/Math.PI);s=(360+s)%360;let e=i,p=Math.sqrt(Math.pow(t-c,2)+Math.pow(o-r,2))/r;return[s,e,p]},m=n=>{let[o,t,i]=n,r=.5,c=.5,h=o/(180/Math.PI),s=i*r,e=r+s*Math.cos(h),l=c+s*Math.sin(h);return[e,l,t]},_=(n=Math.random()*360,o=[Math.random(),Math.random()],t=[.75+Math.random()*.2,.3+Math.random()*.2])=>[[n,o[0],t[0]],[(n+60+Math.random()*180)%360,o[1],t[1]]],L=(n=Math.random()*360,o=[Math.random(),Math.random(),Math.random()],t=[.75+Math.random()*.2,Math.random()*.2,.75+Math.random()*.2])=>[[n,o[0],t[0]],[(n+60+Math.random()*180)%360,o[1],t[1]],[(n+60+Math.random()*180)%360,o[2],t[2]]],X=(n,o,t,i=!1,r=(s,e)=>e?1-s:s,c=(s,e)=>e?1-s:s,h=(s,e)=>e?1-s:s)=>{let s=r(n,i),e=c(n,i),l=h(n,i),p=(1-s)*o[0]+s*t[0],f=(1-e)*o[1]+e*t[1],A=(1-l)*o[2]+l*t[2];return[p,f,A]},z=(n,o,t=4,i=!1,r=(s,e)=>e?1-s:s,c=(s,e)=>e?1-s:s,h=(s,e)=>e?1-s:s)=>{let s=[];for(let e=0;e<t;e++){let[l,p,f]=X(e/(t-1),n,o,i,r,c,h);s.push([l,p,f])}return s},Y=n=>n,Z=(n,o=!1)=>o?1-u(1-n,2):u(n,2),E=(n,o=!1)=>o?1-u(1-n,3):u(n,3),S=(n,o=!1)=>o?1-u(1-n,4):u(n,4),I=(n,o=!1)=>o?1-u(1-n,5):u(n,5),a=(n,o=!1)=>o?1-Math.sin((1-n)*Math.PI/2):Math.sin(n*Math.PI/2),O=(n,o=!1)=>o?1-Math.asin(1-n)/(Math.PI/2):Math.asin(n)/(Math.PI/2),q=(n,o=!1)=>o?Math.sqrt(1-u(1-n,2)):1-Math.sqrt(1-n),T=n=>u(n,2)*(3-2*n),$={linearPosition:Y,exponentialPosition:Z,quadraticPosition:E,cubicPosition:S,quarticPosition:I,sinusoidalPosition:a,asinusoidalPosition:O,arcPosition:q,smoothStepPosition:T},V=(n,o,t=!1)=>{let i=n[0],r=o[0],c=0;t&&i!==null&&r!==null?(c=Math.min(Math.abs(i-r),360-Math.abs(i-r)),c=c/360):c=i===null||r===null?0:i-r;let h=c,s=n[1]===null||o[1]===null?0:o[1]-n[1],e=n[2]===null||o[2]===null?0:o[2]-n[2];return Math.sqrt(h*h+s*s+e*e)},b=class{constructor({xyz:o,color:t}={}){this.x=0;this.y=0;this.z=0;this.color=[0,0,0];this.positionOrColor({xyz:o,color:t})}positionOrColor({xyz:o,color:t}){if(o&&t)throw new Error("Point must be initialized with either x,y,z or hsl");o?(this.x=o[0],this.y=o[1],this.z=o[2],this.color=M([this.x,this.y,this.z])):t&&(this.color=t,[this.x,this.y,this.z]=m(t))}set position([o,t,i]){this.x=o,this.y=t,this.z=i,this.color=M([this.x,this.y,this.z])}get position(){return[this.x,this.y,this.z]}set hsl([o,t,i]){this.color=[o,t,i],[this.x,this.y,this.z]=m(this.color)}get hsl(){return this.color}get hslCSS(){return`hsl(${this.color[0].toFixed(2)}, ${(this.color[1]*100).toFixed(2)}%, ${(this.color[2]*100).toFixed(2)}%)`}shiftHue(o){this.color[0]=(360+(this.color[0]+o))%360,[this.x,this.y,this.z]=m(this.color)}},d=class{constructor({anchorColors:o=_(),numPoints:t=4,positionFunction:i=a,positionFunctionX:r,positionFunctionY:c,positionFunctionZ:h,closedLoop:s}={anchorColors:_(),numPoints:4,positionFunction:a,closedLoop:!1}){this._needsUpdate=!0;this._positionFunctionX=a;this._positionFunctionY=a;this._positionFunctionZ=a;this.connectLastAndFirstAnchor=!1;this._animationFrame=null;if(!o||o.length<2)throw new Error("Must have at least two anchor colors");this._anchorPoints=o.map(e=>new b({color:e})),this._numPoints=t+2,this._positionFunctionX=r||i||a,this._positionFunctionY=c||i||a,this._positionFunctionZ=h||i||a,this.connectLastAndFirstAnchor=s,this.updateAnchorPairs()}get numPoints(){return this._numPoints-2}set numPoints(o){if(o<1)throw new Error("Must have at least one point");this._numPoints=o+2,this.updateAnchorPairs()}set positionFunction(o){if(Array.isArray(o)){if(o.length!==3)throw new Error("Position function array must have 3 elements");if(typeof o[0]!="function"||typeof o[1]!="function"||typeof o[2]!="function")throw new Error("Position function array must have 3 functions");this._positionFunctionX=o[0],this._positionFunctionY=o[1],this._positionFunctionZ=o[2]}else this._positionFunctionX=o,this._positionFunctionY=o,this._positionFunctionZ=o;this.updateAnchorPairs()}get positionFunction(){return this._positionFunctionX===this._positionFunctionY&&this._positionFunctionX===this._positionFunctionZ?this._positionFunctionX:[this._positionFunctionX,this._positionFunctionY,this._positionFunctionZ]}set positionFunctionX(o){this._positionFunctionX=o,this.updateAnchorPairs()}get positionFunctionX(){return this._positionFunctionX}set positionFunctionY(o){this._positionFunctionY=o,this.updateAnchorPairs()}get positionFunctionY(){return this._positionFunctionY}set positionFunctionZ(o){this._positionFunctionZ=o,this.updateAnchorPairs()}get positionFunctionZ(){return this._positionFunctionZ}get anchorPoints(){return this._anchorPoints}set anchorPoints(o){this._anchorPoints=o,this.updateAnchorPairs()}updateAnchorPairs(){this._anchorPairs=[];let o=this.connectLastAndFirstAnchor?this.anchorPoints.length:this.anchorPoints.length-1;for(let t=0;t<o;t++){let i=[this.anchorPoints[t],this.anchorPoints[(t+1)%this.anchorPoints.length]];this._anchorPairs.push(i)}this.points=this._anchorPairs.map((t,i)=>{let r=t[0]?t[0].position:[0,0,0],c=t[1]?t[1].position:[0,0,0];return z(r,c,this._numPoints,!!(i%2),this.positionFunctionX,this.positionFunctionY,this.positionFunctionZ).map(h=>new b({xyz:h}))})}addAnchorPoint({xyz:o,color:t,insertAtIndex:i}){let r=new b({xyz:o,color:t});return i?this.anchorPoints.splice(i,0,r):this.anchorPoints.push(r),this.updateAnchorPairs(),r}removeAnchorPoint({point:o,index:t}){if(!o&&t===void 0)throw new Error("Must provide a point or index");let i;if(t!==void 0?i=t:o&&(i=this.anchorPoints.indexOf(o)),i>-1&&i<this.anchorPoints.length)this.anchorPoints.splice(i,1),this.updateAnchorPairs();else throw new Error("Point not found")}updateAnchorPoint({point:o,pointIndex:t,xyz:i,color:r}){if(t&&(o=this.anchorPoints[t]),!o)throw new Error("Must provide a point or pointIndex");if(!i&&!r)throw new Error("Must provide a new xyz position or color");return i&&(o.position=i),r&&(o.hsl=r),this.updateAnchorPairs(),o}getClosestAnchorPoint({xyz:o,hsl:t,maxDistance:i=1}){if(!o&&!t)throw new Error("Must provide a xyz or hsl");let r;o?r=this.anchorPoints.map(s=>V(s.position,o)):t&&(r=this.anchorPoints.map(s=>V(s.hsl,t,!0)));let c=Math.min(...r);if(c>i)return null;let h=r.indexOf(c);return this.anchorPoints[h]||null}set closedLoop(o){this.connectLastAndFirstAnchor=o,this.updateAnchorPairs()}get closedLoop(){return this.connectLastAndFirstAnchor}get flattenedPoints(){return this.points.flat().filter((o,t)=>t!=0?t%this._numPoints:!0)}get colors(){let o=this.flattenedPoints.map(t=>t.color);return this.connectLastAndFirstAnchor&&o.pop(),o}get colorsCSS(){let o=this.flattenedPoints.map(t=>t.hslCSS);return this.connectLastAndFirstAnchor&&o.pop(),o}shiftHue(o=20){this.anchorPoints.forEach(t=>t.shiftHue(o)),this.updateAnchorPairs()}},{p5:P}=globalThis;if(P){console.info("p5 detected, adding poline to p5 prototype");let n=new d;P.prototype.poline=n;let o=()=>n.colors.map(t=>`hsl(${Math.round(t[0])},${t[1]*100}%,${t[2]*100}%)`);P.prototype.polineColors=o,P.prototype.registerMethod("polineColors",P.prototype.polineColors),globalThis.poline=n,globalThis.polineColors=o}
