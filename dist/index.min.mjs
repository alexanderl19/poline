var f=n=>{let[o,t,i]=n,s=.5,c=.5,r=Math.atan2(t-c,o-s)*(180/Math.PI);r=(360+r)%360;let e=i,l=Math.sqrt(Math.pow(t-c,2)+Math.pow(o-s,2))/s;return[r,e,l]},m=n=>{let[o,t,i]=n,s=.5,c=.5,h=o/(180/Math.PI),r=i*s,e=s+r*Math.cos(h),a=c+r*Math.sin(h);return[e,a,t]},F=(n=Math.random()*360,o=[Math.random(),Math.random()],t=[.75+Math.random()*.2,.3+Math.random()*.2])=>[[n,o[0],t[0]],[(n+60+Math.random()*180)%360,o[1],t[1]]],z=(n=Math.random()*360,o=[Math.random(),Math.random(),Math.random()],t=[.75+Math.random()*.2,Math.random()*.2,.75+Math.random()*.2])=>[[n,o[0],t[0]],[(n+60+Math.random()*180)%360,o[1],t[1]],[(n+60+Math.random()*180)%360,o[2],t[2]]],V=(n,o,t,i=!1,s=(r,e)=>e?1-r:r,c=(r,e)=>e?1-r:r,h=(r,e)=>e?1-r:r)=>{let r=s(n,i),e=c(n,i),a=h(n,i),l=(1-r)*o[0]+r*t[0],b=(1-e)*o[1]+e*t[1],_=(1-a)*o[2]+a*t[2];return[l,b,_]},A=(n,o,t=4,i=!1,s=(r,e)=>e?1-r:r,c=(r,e)=>e?1-r:r,h=(r,e)=>e?1-r:r)=>{let r=[];for(let e=0;e<t;e++){let[a,l,b]=V(e/(t-1),n,o,i,s,c,h);r.push([a,l,b])}return r},x=n=>n,y=(n,o=!1)=>o?1-(1-n)**2:n**2,C=(n,o=!1)=>o?1-(1-n)**3:n**3,w=(n,o=!1)=>o?1-(1-n)**4:n**4,v=(n,o=!1)=>o?1-(1-n)**5:n**5,u=(n,o=!1)=>o?1-Math.sin((1-n)*Math.PI/2):Math.sin(n*Math.PI/2),g=(n,o=!1)=>o?1-Math.asin(1-n)/(Math.PI/2):Math.asin(n)/(Math.PI/2),L=(n,o=!1)=>o?Math.sqrt(1-(1-n)**2):1-Math.sqrt(1-n),X=n=>n**2*(3-2*n),Y={linearPosition:x,exponentialPosition:y,quadraticPosition:C,cubicPosition:w,quarticPosition:v,sinusoidalPosition:u,asinusoidalPosition:g,arcPosition:L,smoothStepPosition:X},M=(n,o,t=!1)=>{let i=n[0],s=o[0],c=0;t&&i!==null&&s!==null?(c=Math.min(Math.abs(i-s),360-Math.abs(i-s)),c=c/360):c=i===null||s===null?0:i-s;let h=c,r=n[1]===null||o[1]===null?0:o[1]-n[1],e=n[2]===null||o[2]===null?0:o[2]-n[2];return Math.sqrt(h*h+r*r+e*e)},P=class{constructor({xyz:o,color:t}={}){this.x=0;this.y=0;this.z=0;this.color=[0,0,0];this.positionOrColor({xyz:o,color:t})}positionOrColor({xyz:o,color:t}){if(o&&t)throw new Error("Point must be initialized with either x,y,z or hsl");o?(this.x=o[0],this.y=o[1],this.z=o[2],this.color=f([this.x,this.y,this.z])):t&&(this.color=t,[this.x,this.y,this.z]=m(t))}set position([o,t,i]){this.x=o,this.y=t,this.z=i,this.color=f([this.x,this.y,this.z])}get position(){return[this.x,this.y,this.z]}set hsl([o,t,i]){this.color=[o,t,i],[this.x,this.y,this.z]=m(this.color)}get hsl(){return this.color}get hslCSS(){return`hsl(${this.color[0].toFixed(2)}, ${(this.color[1]*100).toFixed(2)}%, ${(this.color[2]*100).toFixed(2)}%)`}shiftHue(o){this.color[0]=(360+(this.color[0]+o))%360,[this.x,this.y,this.z]=m(this.color)}},d=class{constructor({anchorColors:o=F(),numPoints:t=4,positionFunction:i=u,positionFunctionX:s,positionFunctionY:c,positionFunctionZ:h,closedLoop:r}={anchorColors:F(),numPoints:4,positionFunction:u,closedLoop:!1}){this._needsUpdate=!0;this._positionFunctionX=u;this._positionFunctionY=u;this._positionFunctionZ=u;this.connectLastAndFirstAnchor=!1;this._animationFrame=null;if(!o||o.length<2)throw new Error("Must have at least two anchor colors");this._anchorPoints=o.map(e=>new P({color:e})),this._numPoints=t+2,this._positionFunctionX=s||i||u,this._positionFunctionY=c||i||u,this._positionFunctionZ=h||i||u,this.connectLastAndFirstAnchor=r,this.updateAnchorPairs()}get numPoints(){return this._numPoints-2}set numPoints(o){if(o<1)throw new Error("Must have at least one point");this._numPoints=o+2,this.updateAnchorPairs()}set positionFunction(o){if(Array.isArray(o)){if(o.length!==3)throw new Error("Position function array must have 3 elements");if(typeof o[0]!="function"||typeof o[1]!="function"||typeof o[2]!="function")throw new Error("Position function array must have 3 functions");this._positionFunctionX=o[0],this._positionFunctionY=o[1],this._positionFunctionZ=o[2]}else this._positionFunctionX=o,this._positionFunctionY=o,this._positionFunctionZ=o;this.updateAnchorPairs()}get positionFunction(){return this._positionFunctionX===this._positionFunctionY&&this._positionFunctionX===this._positionFunctionZ?this._positionFunctionX:[this._positionFunctionX,this._positionFunctionY,this._positionFunctionZ]}set positionFunctionX(o){this._positionFunctionX=o,this.updateAnchorPairs()}get positionFunctionX(){return this._positionFunctionX}set positionFunctionY(o){this._positionFunctionY=o,this.updateAnchorPairs()}get positionFunctionY(){return this._positionFunctionY}set positionFunctionZ(o){this._positionFunctionZ=o,this.updateAnchorPairs()}get positionFunctionZ(){return this._positionFunctionZ}get anchorPoints(){return this._anchorPoints}set anchorPoints(o){this._anchorPoints=o,this.updateAnchorPairs()}updateAnchorPairs(){this._anchorPairs=[];let o=this.connectLastAndFirstAnchor?this.anchorPoints.length:this.anchorPoints.length-1;for(let t=0;t<o;t++){let i=[this.anchorPoints[t],this.anchorPoints[(t+1)%this.anchorPoints.length]];this._anchorPairs.push(i)}this.points=this._anchorPairs.map((t,i)=>{let s=t[0]?t[0].position:[0,0,0],c=t[1]?t[1].position:[0,0,0];return A(s,c,this._numPoints,!!(i%2),this.positionFunctionX,this.positionFunctionY,this.positionFunctionZ).map(h=>new P({xyz:h}))})}addAnchorPoint({xyz:o,color:t,insertAtIndex:i}){let s=new P({xyz:o,color:t});return i?this.anchorPoints.splice(i,0,s):this.anchorPoints.push(s),this.updateAnchorPairs(),s}removeAnchorPoint({point:o,index:t}){if(!o&&t===void 0)throw new Error("Must provide a point or index");let i;if(t!==void 0?i=t:o&&(i=this.anchorPoints.indexOf(o)),i>-1&&i<this.anchorPoints.length)this.anchorPoints.splice(i,1),this.updateAnchorPairs();else throw new Error("Point not found")}updateAnchorPoint({point:o,pointIndex:t,xyz:i,color:s}){if(t&&(o=this.anchorPoints[t]),!o)throw new Error("Must provide a point or pointIndex");if(!i&&!s)throw new Error("Must provide a new xyz position or color");return i&&(o.position=i),s&&(o.hsl=s),this.updateAnchorPairs(),o}getClosestAnchorPoint({xyz:o,hsl:t,maxDistance:i=1}){if(!o&&!t)throw new Error("Must provide a xyz or hsl");let s;o?s=this.anchorPoints.map(r=>M(r.position,o)):t&&(s=this.anchorPoints.map(r=>M(r.hsl,t,!0)));let c=Math.min(...s);if(c>i)return null;let h=s.indexOf(c);return this.anchorPoints[h]||null}set closedLoop(o){this.connectLastAndFirstAnchor=o,this.updateAnchorPairs()}get closedLoop(){return this.connectLastAndFirstAnchor}get flattenedPoints(){return this.points.flat().filter((o,t)=>t!=0?t%this._numPoints:!0)}get colors(){let o=this.flattenedPoints.map(t=>t.color);return this.connectLastAndFirstAnchor&&o.pop(),o}get colorsCSS(){let o=this.flattenedPoints.map(t=>t.hslCSS);return this.connectLastAndFirstAnchor&&o.pop(),o}shiftHue(o=20){this.anchorPoints.forEach(t=>t.shiftHue(o)),this.updateAnchorPairs()}},{p5:p}=globalThis;if(p){console.info("p5 detected, adding poline to p5 prototype");let n=new d;p.prototype.poline=n;let o=()=>n.colors.map(t=>`hsl(${Math.round(t[0])},${t[1]*100}%,${t[2]*100}%)`);p.prototype.polineColors=o,p.prototype.registerMethod("polineColors",p.prototype.polineColors),globalThis.poline=n,globalThis.polineColors=o}export{d as Poline,m as hslToPoint,f as pointToHSL,Y as positionFunctions,F as randomHSLPair,z as randomHSLTriple};
